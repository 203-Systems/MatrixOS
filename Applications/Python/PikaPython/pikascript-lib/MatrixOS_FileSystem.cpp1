#include <functional>
#include "MatrixOS.h"
#include "pikaScript.h"
#include "PikaObj.h"
#include "PikaObjUtils.h"

extern "C" {

    // Forward declarations
    PikaObj* New__MatrixOS_FileSystem_FileObject(Args *args);

    // Helper function to check if path is attempting sandbox escape
    static bool IsRootFSPath(const string& path) {
        return (path.length() >= 2 && path.substr(0, 2) == "//") ||
               (path.length() >= 7 && path.substr(0, 7) == "rootfs:/");
    }

    // Helper function to convert Python mode string to AccessMode
    static MatrixOS::File::AccessMode ParseFileMode(const char* mode) {
        if (!mode) return MatrixOS::File::AccessMode::READ;

        string modeStr = string(mode);
        MatrixOS::File::AccessMode accessMode = MatrixOS::File::AccessMode::OPEN_EXISTING;

        // Parse mode string (simplified Python-like parsing)
        if (modeStr.find('r') != string::npos) {
            accessMode = (MatrixOS::File::AccessMode)(accessMode | MatrixOS::File::AccessMode::read);
        }
        if (modeStr.find('w') != string::npos) {
            accessMode = (MatrixOS::File::AccessMode)(accessMode | MatrixOS::File::AccessMode::WRITE | MatrixOS::File::AccessMode::CREATE_ALWAYS);
        }
        if (modeStr.find('a') != string::npos) {
            accessMode = (MatrixOS::File::AccessMode)(accessMode | MatrixOS::File::AccessMode::WRITE | MatrixOS::File::AccessMode::OPEN_APPEND);
        }
        if (modeStr.find('+') != string::npos) {
            accessMode = (MatrixOS::File::AccessMode)(accessMode | MatrixOS::File::AccessMode::read | MatrixOS::File::AccessMode::WRITE);
        }

        return accessMode;
    }

    // FileSystem functions implementation

    // open function - creates a FileObject
    PikaObj* _MatrixOS_FileSystem_open(PikaObj *self, char* file, PikaObj* mode, PikaObj* buffering, PikaObj* encoding) {
        string pathStr = string(file);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return NULL;
        }

        // Get mode string (default to "r")
        char* modeStr = "r";
        if (mode && arg_getType((Arg*)mode) == ARG_TYPE_STRING) {
            modeStr = arg_getStr((Arg*)mode);
        }

        // Create FileObject with path and mode
        PikaObj* fileObj = New__MatrixOS_FileSystem_FileObject(NULL);

        // Initialize the FileObject
        obj_setStr(fileObj, "_path", pathStr.c_str());
        obj_setStr(fileObj, "_mode", modeStr);
        obj_setInt(fileObj, "_is_open", 0);

        return fileObj;
    }

    // listdir function
    PikaObj* _MatrixOS_FileSystem_listdir(PikaObj *self, PikaObj* path) {
        string pathStr = "."; // Default to current directory

        if (path && arg_getType((Arg*)path) == ARG_TYPE_STRING) {
            pathStr = string(arg_getStr((Arg*)path));
        }

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            // Return empty list for denied access
            return newNormalObj(New_PikaStdLib_List);
        }

        vector<string> files = MatrixOS::File::ListDir(pathStr);

        // Create Python list object
        PikaObj* listObj = newNormalObj(New_PikaStdLib_List);

        for (const string& filename : files) {
            // Add each filename to the list
            Arg* filenameArg = arg_newStr(filename.c_str());
            obj_setArg(listObj, "__append__", filenameArg);
            arg_deinit(filenameArg);
        }

        return listObj;
    }

    // mkdir function
    void _MatrixOS_FileSystem_mkdir(PikaObj *self, char* path, PikaObj* mode) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return;
        }

        MatrixOS::File::CreateDir(pathStr);
    }

    // makedirs function
    void _MatrixOS_FileSystem_makedirs(PikaObj *self, char* path, PikaObj* mode, PikaObj* exist_ok) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return;
        }

        // For now, just create the directory (simplified implementation)
        // TODO: Implement recursive directory creation
        MatrixOS::File::CreateDir(pathStr);
    }

    // remove function
    void _MatrixOS_FileSystem_remove(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return;
        }

        MatrixOS::File::Delete(pathStr);
    }

    // rmdir function
    void _MatrixOS_FileSystem_rmdir(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return;
        }

        MatrixOS::File::Delete(pathStr);
    }

    // rename function
    void _MatrixOS_FileSystem_rename(PikaObj *self, char* src, char* dst) {
        string srcStr = string(src);
        string dstStr = string(dst);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(srcStr) || IsRootFSPath(dstStr)) {
            return;
        }

        MatrixOS::File::Rename(srcStr, dstStr);
    }

    // getcwd function
    char* _MatrixOS_FileSystem_getcwd(PikaObj *self) {
        // Return the app's sandbox directory as current working directory
        return "/";  // Simplified - always return root of sandbox
    }

    // chdir function
    void _MatrixOS_FileSystem_chdir(PikaObj *self, char* path) {
        // For now, do nothing as we maintain current directory in sandbox
        // TODO: Could implement current directory tracking
    }

    // FileObject implementation

    // FileObject constructor
    void _MatrixOS_FileSystem_FileObject___init__(PikaObj *self, char* path, char* mode) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            obj_setInt(self, "_is_open", 0);
            return;
        }

        // Parse mode and open file
        MatrixOS::File::AccessMode accessMode = ParseFileMode(mode);

        MatrixOS::File::File* file = new MatrixOS::File::File;
        MatrixOS::File::FResult result = MatrixOS::File::Open(file, pathStr, accessMode);

        if (MatrixOS::File::IsOK(result)) {
            setCppObjPtrInPikaObj<MatrixOS::File::File>(self, file);
            obj_setInt(self, "_is_open", 1);
            obj_setStr(self, "_mode", mode);
        } else {
            delete file;
            obj_setInt(self, "_is_open", 0);
        }
    }

    // FileObject destructor
    void _MatrixOS_FileSystem_FileObject___del__(PikaObj *self) {
        if (obj_getInt(self, "_is_open")) {
            MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
            if (filePtr) {
                MatrixOS::File::Close(filePtr);
                delete filePtr;
                obj_setInt(self, "_is_open", 0);
            }
        }
    }

    // Context manager enter
    PikaObj* _MatrixOS_FileSystem_FileObject___enter__(PikaObj *self) {
        return self;  // Return self for context manager
    }

    // Context manager exit
    void _MatrixOS_FileSystem_FileObject___exit__(PikaObj *self) {
        _MatrixOS_FileSystem_FileObject_close(self);
    }

    // Close file
    void _MatrixOS_FileSystem_FileObject_close(PikaObj *self) {
        if (obj_getInt(self, "_is_open")) {
            MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
            if (filePtr) {
                MatrixOS::File::Close(filePtr);
                delete filePtr;
                setCppObjPtrInPikaObj<MatrixOS::File::File>(self, NULL);
                obj_setInt(self, "_is_open", 0);
            }
        }
    }

    // Check if file is closed
    pika_bool _MatrixOS_FileSystem_FileObject_closed(PikaObj *self) {
        return !obj_getInt(self, "_is_open");
    }

    // Flush file
    void _MatrixOS_FileSystem_FileObject_flush(PikaObj *self) {
        if (obj_getInt(self, "_is_open")) {
            MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
            if (filePtr) {
                MatrixOS::File::Flush(filePtr);
            }
        }
    }

    // Read from file
    PikaObj* _MatrixOS_FileSystem_FileObject_read(PikaObj *self, PikaObj* size) {
        if (!obj_getInt(self, "_is_open")) {
            return arg_newNull();
        }

        MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
        if (!filePtr) return arg_newNull();

        int readSize = -1;
        if (size && arg_getType((Arg*)size) == ARG_TYPE_INT) {
            readSize = arg_getInt((Arg*)size);
        }

        // Default read size if not specified
        if (readSize <= 0) readSize = 1024;

        // Allocate buffer for reading
        uint8_t* buffer = (uint8_t*)malloc(readSize);
        if (!buffer) return arg_newNull();

        size_t bytesRead;
        MatrixOS::File::FResult result = MatrixOS::File::Read(filePtr, buffer, readSize, &bytesRead);

        if (!MatrixOS::File::IsOK(result) || bytesRead == 0) {
            free(buffer);
            return arg_newNull();
        }

        // Create Python bytes object
        Arg* bytesArg = arg_newBytes(buffer, bytesRead);
        free(buffer);

        PikaObj* bytesObj = arg_getPtr(bytesArg);
        arg_deinit(bytesArg);

        return bytesObj;
    }

    // Write to file
    int _MatrixOS_FileSystem_FileObject_write(PikaObj *self, PikaObj* data) {
        if (!obj_getInt(self, "_is_open")) {
            return 0;
        }

        MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
        if (!filePtr || !data) return 0;

        if (arg_getType((Arg*)data) == ARG_TYPE_STRING) {
            // Handle string data
            char* str = arg_getStr((Arg*)data);
            size_t len = strlen(str);

            size_t bytesWritten;
            MatrixOS::File::FResult result = MatrixOS::File::Write(filePtr, str, len, &bytesWritten);

            return MatrixOS::File::IsOK(result) ? (int)bytesWritten : 0;
        } else if (arg_getType((Arg*)data) == ARG_TYPE_BYTES) {
            // Handle bytes data
            size_t dataSize;
            uint8_t* dataBytes = arg_getBytes((Arg*)data, &dataSize);

            size_t bytesWritten;
            MatrixOS::File::FResult result = MatrixOS::File::Write(filePtr, dataBytes, dataSize, &bytesWritten);

            return MatrixOS::File::IsOK(result) ? (int)bytesWritten : 0;
        }

        return 0;
    }

    // Seek in file
    int _MatrixOS_FileSystem_FileObject_seek(PikaObj *self, int offset, PikaObj* whence) {
        if (!obj_getInt(self, "_is_open")) {
            return -1;
        }

        MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
        if (!filePtr) return -1;

        MatrixOS::File::SeekMode seekMode = MatrixOS::File::SEEK_SET;
        if (whence && arg_getType((Arg*)whence) == ARG_TYPE_INT) {
            int w = arg_getInt((Arg*)whence);
            if (w == 1) seekMode = MatrixOS::File::SEEK_CUR;
            else if (w == 2) seekMode = MatrixOS::File::SEEK_END;
        }

        MatrixOS::File::FResult result = MatrixOS::File::Seek(filePtr, offset, seekMode);

        if (MatrixOS::File::IsOK(result)) {
            size_t position;
            MatrixOS::File::Tell(filePtr, &position);
            return (int)position;
        }

        return -1;
    }

    // Get current position
    int _MatrixOS_FileSystem_FileObject_tell(PikaObj *self) {
        if (!obj_getInt(self, "_is_open")) {
            return -1;
        }

        MatrixOS::File::File* filePtr = getCppObjPtrInPikaObj<MatrixOS::File::File>(self);
        if (!filePtr) return -1;

        size_t position;
        MatrixOS::File::FResult result = MatrixOS::File::Tell(filePtr, &position);

        return MatrixOS::File::IsOK(result) ? (int)position : -1;
    }

    // Check if readable
    pika_bool _MatrixOS_FileSystem_FileObject_readable(PikaObj *self) {
        if (!obj_getInt(self, "_is_open")) return false;

        char* mode = obj_getStr(self, "_mode");
        if (!mode) return false;

        string modeStr = string(mode);
        return (modeStr.find('r') != string::npos || modeStr.find('+') != string::npos);
    }

    // Check if writable
    pika_bool _MatrixOS_FileSystem_FileObject_writable(PikaObj *self) {
        if (!obj_getInt(self, "_is_open")) return false;

        char* mode = obj_getStr(self, "_mode");
        if (!mode) return false;

        string modeStr = string(mode);
        return (modeStr.find('w') != string::npos || modeStr.find('a') != string::npos || modeStr.find('+') != string::npos);
    }

    // Check if seekable
    pika_bool _MatrixOS_FileSystem_FileObject_seekable(PikaObj *self) {
        return obj_getInt(self, "_is_open");  // All files are seekable in our implementation
    }

    // Readline (simplified implementation)
    PikaObj* _MatrixOS_FileSystem_FileObject_readline(PikaObj *self, PikaObj* size) {
        // For now, just read a chunk and return it
        // TODO: Implement proper line reading
        return _MatrixOS_FileSystem_FileObject_read(self, size);
    }

    // Readlines (simplified implementation)
    PikaObj* _MatrixOS_FileSystem_FileObject_readlines(PikaObj *self, PikaObj* hint) {
        // For now, return a list with one item (the entire file content)
        // TODO: Implement proper line-by-line reading
        PikaObj* listObj = newNormalObj(New_PikaStdLib_List);
        PikaObj* content = _MatrixOS_FileSystem_FileObject_read(self, NULL);

        if (content) {
            Arg* contentArg = arg_newObj(content);
            obj_setArg(listObj, "__append__", contentArg);
            arg_deinit(contentArg);
        }

        return listObj;
    }

    // Writelines
    void _MatrixOS_FileSystem_FileObject_writelines(PikaObj *self, PikaObj* lines) {
        // TODO: Implement proper writelines
        // For now, do nothing
    }

    // Path utility functions

    // path.exists
    pika_bool _MatrixOS_FileSystem_path_exists(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return false;
        }

        return MatrixOS::File::Exists(pathStr);
    }

    // path.isfile
    pika_bool _MatrixOS_FileSystem_path_isfile(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return false;
        }

        return MatrixOS::File::Exists(pathStr) && !MatrixOS::File::IsDirectory(pathStr);
    }

    // path.isdir
    pika_bool _MatrixOS_FileSystem_path_isdir(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return false;
        }

        return MatrixOS::File::IsDirectory(pathStr);
    }

    // path.getsize
    int _MatrixOS_FileSystem_path_getsize(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Deny sandbox escape attempts for Python apps
        if (IsRootFSPath(pathStr)) {
            return 0;
        }

        MatrixOS::File::FileInfo info;
        MatrixOS::File::FResult result = MatrixOS::File::GetFileInfo(pathStr, &info);

        return MatrixOS::File::IsOK(result) ? (int)info.fsize : 0;
    }

    // path.basename
    char* _MatrixOS_FileSystem_path_basename(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Find last slash
        size_t lastSlash = pathStr.find_last_of("/\\");
        if (lastSlash == string::npos) {
            // No slash found, return the whole path
            return path;
        }

        // Return substring after last slash
        string basename = pathStr.substr(lastSlash + 1);

        // Allocate memory for return value
        char* result = (char*)malloc(basename.length() + 1);
        strcpy(result, basename.c_str());
        return result;
    }

    // path.dirname
    char* _MatrixOS_FileSystem_path_dirname(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Find last slash
        size_t lastSlash = pathStr.find_last_of("/\\");
        if (lastSlash == string::npos) {
            // No slash found, return "."
            char* result = (char*)malloc(2);
            strcpy(result, ".");
            return result;
        }

        // Return substring before last slash
        string dirname = pathStr.substr(0, lastSlash);
        if (dirname.empty()) dirname = "/";

        // Allocate memory for return value
        char* result = (char*)malloc(dirname.length() + 1);
        strcpy(result, dirname.c_str());
        return result;
    }

    // path.join
    char* _MatrixOS_FileSystem_path_join(PikaObj *self, char* paths) {
        // For now, just return the input path (simplified implementation)
        // TODO: Implement proper path joining with multiple arguments
        char* result = (char*)malloc(strlen(paths) + 1);
        strcpy(result, paths);
        return result;
    }

    // path.splitext
    PikaObj* _MatrixOS_FileSystem_path_splitext(PikaObj *self, char* path) {
        string pathStr = string(path);

        // Find last dot
        size_t lastDot = pathStr.find_last_of('.');

        // Create tuple-like list with [name, extension]
        PikaObj* listObj = newNormalObj(New_PikaStdLib_List);

        if (lastDot == string::npos) {
            // No extension found
            Arg* nameArg = arg_newStr(pathStr.c_str());
            Arg* extArg = arg_newStr("");
            obj_setArg(listObj, "__append__", nameArg);
            obj_setArg(listObj, "__append__", extArg);
            arg_deinit(nameArg);
            arg_deinit(extArg);
        } else {
            // Split at last dot
            string name = pathStr.substr(0, lastDot);
            string ext = pathStr.substr(lastDot);

            Arg* nameArg = arg_newStr(name.c_str());
            Arg* extArg = arg_newStr(ext.c_str());
            obj_setArg(listObj, "__append__", nameArg);
            obj_setArg(listObj, "__append__", extArg);
            arg_deinit(nameArg);
            arg_deinit(extArg);
        }

        return listObj;
    }
}